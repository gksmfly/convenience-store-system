## REVIEW

### 1. 좋았던 것

* **요구사항 기반의 체계적인 개발 흐름 정립**
    초기에 '요구사항 분석 → 데이터 모델링 → 서비스 로직 구현'으로 이어지는 명확한 개발 흐름을 정립한 것이 프로젝트를 안정적으로 이끌었습니다. 이 접근법 덕분에 각 단계에서 수행해야 할 작업이 뚜렷해져 불필요한 고민 없이 구현에 집중할 수 있었습니다. 결과적으로 전체 개발 속도를 크게 단축시켰고, 기능 추가 시에도 어떤 부분을 수정해야 할지 빠르게 파악하는 데 큰 도움이 되었습니다.

* **인터페이스를 활용한 유연한 정책 관리**
    할인율이나 재고 부족 임계치 같은 핵심 정책들을 별도의 인터페이스로 추상화하여 설계한 것이 매우 효과적이었습니다. 이를 통해 정책이 변경될 때마다 관련 비즈니스 로직 코드를 일일이 수정할 필요 없이, 해당 인터페이스의 구현체만 교체하면 되도록 만들었습니다. 이러한 설계는 코드의 결합도를 낮추고 유연성을 극대화하여, 향후 새로운 할인 이벤트나 재고 관리 기준이 추가되더라도 시스템을 쉽게 확장할 수 있는 기반을 마련했습니다.

* **CSV 파일을 통한 데이터 관리 효율화**
    다양한 테스트 시나리오를 검증하기 위해 상품 및 판매 데이터를 외부 CSV 파일로부터 읽어오도록 구현한 점이 주효했습니다. 코드 내부에 데이터를 하드코딩하는 방식에서 벗어나, 외부에서 데이터를 주입함으로써 여러 종류의 데이터셋으로 시스템을 손쉽게 테스트하고 시연할 수 있었습니다. 덕분에 개발 단계에서는 소규모 데이터로 빠르게 기능을 검증하고, 최종 시연에서는 대규모의 복잡한 데이터를 사용하여 시스템의 안정성과 성능을 효과적으로 보여줄 수 있었습니다.

##
### 2. 배운 것

* **Kotlin 언어 특성을 활용한 코드 품질 향상**
    Kotlin이 제공하는 `data class`, `sealed interface`, `extension function`과 같은 현대적인 언어 기능들을 적극적으로 활용하며 코드의 품질을 높이는 방법을 배웠습니다. `data class`는 상태를 저장하는 모델 객체를 불변하고 간결하게 만들어주었고, `sealed interface`는 상품의 다양한 타입을 컴파일 시점에 확인할 수 있게 하여 안정성을 더했습니다. [cite_start]특히, `extension function`은 기존 클래스를 수정하지 않고도 분석 기능을 추가하게 해주어 코드의 응집도를 높이는 데 결정적인 역할을 했습니다. [cite: 88, 91]

* **컬렉션 파이프라인을 통한 함수형 프로그래밍 체득**
    `map`, `filter`, `groupBy` 등으로 대표되는 컬렉션 파이프라인을 사용하여 복잡한 데이터 집계 로직을 매우 효율적으로 처리하는 함수형 프로그래밍 기법을 익혔습니다. [cite_start]기존의 반복문 기반 처리 방식이었다면 여러 줄에 걸쳐 복잡하게 작성되었을 리포트 생성 로직을, 데이터의 흐름에 따라 함수를 연쇄적으로 호출하는 방식으로 명료하게 표현할 수 있었습니다. [cite: 92] 이는 코드의 길이를 줄여주었을 뿐만 아니라, '무엇을' 할 것인지에 집중하는 선언적인 스타일로 작성되어 다른 개발자가 코드를 이해하고 수정하기 훨씬 용이하게 만들었습니다.

* **Gradle을 이용한 실행 가능한 JAR 패키징 및 배포**
    [cite_start]Gradle의 Application 및 Shadow 플러그인을 활용하여 프로젝트를 실행 가능한 JAR 파일로 패키징하고 배포하는 전체 과정을 직접 경험하며 배웠습니다. [cite: 286] [cite_start]단순히 개발 환경에서 코드를 실행하는 것을 넘어, 다른 환경에서도 JDK만 설치되어 있다면 명령어 한 줄로 프로그램을 실행할 수 있도록 만드는 과정은 소프트웨어 배포의 기본을 이해하는 데 필수적이었습니다. [cite: 253] 이 경험을 통해 프로젝트 빌드, 의존성 관리, 배포 자동화의 중요성을 깨달았고, 향후 더 복잡한 애플리케이션을 만들 때에도 자신감 있게 빌드 및 배포 파이프라인을 구성할 수 있는 기반 지식을 쌓게 되었습니다.

### 3. 놀라웠던 것

* **경계값 조건에서 발생하는 버그의 위험성**
    유통기한 임박 상품에 대한 할인 로직을 구현하면서, D-3, D-2, D-1, 당일 등 특정 경계값에서 논리적 오류가 예상보다 훨씬 쉽게 발생할 수 있다는 점에 놀랐습니다. '이하', '미만', '초과'와 같은 미세한 조건 차이가 전혀 다른 결과를 만들어냈기 때문에, 단순해 보이는 로직이라도 잠재적인 버그를 품고 있을 수 있다는 사실을 깨달았습니다. 이 경험은 모든 기능, 특히 경계 조건을 다루는 로직에 대해서는 반드시 꼼꼼한 단위 테스트 케이스를 작성해야 한다는 교훈을 주었고, 테스트 자동화의 중요성을 절실히 느끼게 된 계기가 되었습니다.

* **간단한 예외 처리가 사용자 경험에 미치는 영향**
    비록 간단한 콘솔 기반 애플리케이션이었지만, 의도치 않은 입력에 대한 예외 처리가 있고 없음이 전체적인 사용자 경험에 지대한 영향을 미친다는 사실이 인상 깊었습니다. 견고한 예외 처리 로직이 없다면 사소한 사용자 실수 하나만으로도 프로그램 전체가 비정상적으로 종료될 수 있었고, 이는 시스템에 대한 신뢰도를 크게 떨어뜨리는 요인이 되었습니다. 이를 통해 기능의 완벽한 구현만큼이나 사용자의 모든 잠재적 행동을 예측하고 방어하는 코드를 작성하는 것이 얼마나 중요한지 배웠습니다.

* **스토리 기반의 문제 해결 방식이 주는 몰입감**
    [cite_start]'탄지로'라는 가상 인물의 문제 해결 스토리를 따라가며 시스템을 개발하는 과제 방식이 생각보다 훨씬 더 개발에 몰입하게 만드는 원동력이 된다는 점이 놀라웠습니다. [cite: 5, 20] [cite_start]단순히 '재고 관리 시스템 구현'이라는 추상적인 목표 대신, 실제 사용자가 겪는 구체적인 문제(품절, 유통기한, 매출 분석 부재)를 해결해나가는 과정은 [cite: 10, 13, 16] 각 기능의 필요성을 명확히 이해하고 동기를 부여하는 데 큰 도움이 되었습니다. 이 경험을 통해 기술적인 구현 능력뿐만 아니라, 사용자의 입장에서 문제를 정의하고 해결책을 제시하는 '문제 해결 능력'이 개발자에게 얼마나 중요한 역량인지 다시 한번 깨닫게 되었습니다.

### 4. 부족했던 것 / 개선점

* **핵심 로직에 대한 테스트 커버리지 부족**
    프로젝트의 핵심 비즈니스 로직(할인 계산, 재고율 분석 등)에 대한 단위 테스트 커버리지가 현저히 낮은 점이 가장 아쉬운 부분입니다. 개발 과정에서 기능 구현에 집중하다 보니, 다양한 예외 상황이나 경계값에 대한 테스트 케이스를 충분히 확보하지 못했습니다. 향후에는 반드시 JUnit, Kotest 등의 테스트 프레임워크를 도입하여 주요 로직에 대한 테스트 코드를 보강하고, 코드 변경 시 회귀 테스트가 자동으로 수행되도록 하여 시스템의 신뢰도를 높여야 합니다.

* **콘솔 환경에만 종속된 리포트 출력 방식**
    현재 시스템이 생성하는 모든 분석 리포트가 단순 콘솔 텍스트 형태로만 제공되어 데이터의 활용성이 떨어지는 한계가 있습니다. 콘솔 출력은 즉각적인 확인에는 용이하지만, 결과를 저장하거나 다른 프로그램(예: 엑셀)에서 재가공하기에는 매우 비효율적인 방식입니다. 이 문제를 해결하기 위해, 향후에는 리포트 결과를 표준화된 형식인 CSV나 Markdown 파일로 생성하는 기능을 추가하여 사용자가 데이터를 자유롭게 가공하고 더 깊이 있는 인사이트를 얻을 수 있도록 개선해야 합니다.

* **데이터 영속성 부재로 인한 기능의 한계**
    현재 시스템은 프로그램이 실행될 때만 데이터를 메모리에 로드하는 방식이므로, 재고 및 판매 데이터가 영속적으로 유지되지 않는다는 근본적인 문제점이 있습니다. 프로그램이 종료되면 모든 데이터가 사라지기 때문에, 과거 판매 이력을 분석하거나 장기적인 재고 변화를 추적하는 것이 불가능합니다. 다음 단계에서는 이 문제를 해결하기 위해 SQLite나 Room과 같은 경량 데이터베이스를 도입하여 모든 데이터를 영속적으로 관리하고, 실제 운영 환경에 가까운 애플리케이션으로 발전시켜 나갈 계획입니다.
